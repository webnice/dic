//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"encoding/csv"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"
	"time"
)

const (
	sourceData            = "file/"                 // Папка с исходными файлами типов MIME контента с расширениями.
	resultFile            = "file_ext_constants.go" // Имя генерируемого файла.
	dataFormatSystem      = "types"                 // Формат данных применяемый в linux и в apache.
	dataFormatNginxConfig = "cfg"                   // Формат данных применяемый в nginx.
	dataFormatIanaCSV     = "csv"                   // Формат данных https://www.iana.org/assignments/media-types/media-types.xhtml.
	dataFormatXCustom     = "x-custom"              // Формат приоритетных настраиваемых типов MIME.
	fileGitKeep           = "gitkeep"               // Файл .gitkeep.
)

var (
	rexExtension     = regexp.MustCompile(`\.([^\.]+)$`)
	rexSplitter      = regexp.MustCompile(`[\s\W]`)
	rexExtensionBad  = regexp.MustCompile(`[\+\[\]\-]`)
	rexIanaExtension = regexp.MustCompile(`(?mi)^([a-zA-Z0-9\-\+\._]+)`)
	resultTemplate   = `// НЕ РЕДАКТИРОВАТЬ! Изменения будут перезаписаны при следующей кодогенерации.
// Code generated by go generate; DO NOT EDIT.

package dic

const (
{{- range .Types }}
	{{ printf "%s = %q" .Name .Type }}
{{- end }}
)

var mimeTypeExtension = map[string][]string{
{{- range .Types }}
	{{ printf "%s: []string{%s}" .Name (arr .Extension) }},
{{- end }}
}
`
)

// MimeTypeItem Одна запись mime type.
type MimeTypeItem struct {
	Type      string   // Mime-Type.
	Extension []string // File extension.
	Src       string   // Data format source.
	Name      string   // Constant name.
}

func main() { os.Exit(Main()) }

func Main() (ret int) {
	const errUnknownFormat = "неизвестный формат %q, файл %q пропущен"
	var (
		err                  error
		packageTemplate      *template.Template
		buf                  *bytes.Buffer
		dirContent           []os.DirEntry
		mimeTypes, tmp, prio []*MimeTypeItem
		deduplicate          map[string]*MimeTypeItem
		ext, filename        string
		i, n, j              int
		ok                   bool
		data                 []byte
	)

	die(func() error { dirContent, err = os.ReadDir(sourceData); return err },
		"чтение директории %q, прервано ошибкой: %s", sourceData)
	for i = range dirContent {
		if dirContent[i].IsDir() {
			continue
		}
		filename = path.Join(sourceData, dirContent[i].Name())
		switch die(func() error { buf, ext, err = ReadFileBody(filename); return err },
			"чтение тела файла %q, прервано ошибкой: %s", filename); ext {
		case fileGitKeep:
			continue
		case dataFormatSystem:
			tmp, err = ParseDataFormatSystem(buf)
		case dataFormatNginxConfig:
			tmp, err = ParserDataFormatNginxConfig(buf)
		case dataFormatIanaCSV:
			tmp, err = ParseDataFormatIanaCSV(buf)
		case dataFormatXCustom:
			prio, err = ParseDataFormatXCustom(buf)
		default:
			log.Printf(errUnknownFormat, ext, filename)
			continue
		}
		if die(func() error { return err }, "разбор структуры файла %q прерван ошибкой: %s", filename); len(tmp) > 0 {
			mimeTypes = append(mimeTypes, tmp...)
			tmp = tmp[:0]
		}
	}
	deduplicate = make(map[string]*MimeTypeItem)
	for i = range mimeTypes {
		if _, ok = deduplicate[mimeTypes[i].Type]; ok {
			if deduplicate[mimeTypes[i].Type].Name == "" {
				deduplicate[mimeTypes[i].Type].Name = mimeTypes[i].Name
			}
			for j = range mimeTypes[i].Extension {
				ok = false
				for n = range deduplicate[mimeTypes[i].Type].Extension {
					if strings.EqualFold(deduplicate[mimeTypes[i].Type].Extension[n], mimeTypes[i].Extension[j]) {
						ok = true
						break
					}
				}
				if !ok {
					deduplicate[mimeTypes[i].Type].Extension =
						append(deduplicate[mimeTypes[i].Type].Extension, mimeTypes[i].Extension[j])
				}
			}
			switch deduplicate[mimeTypes[i].Type].Src {
			case dataFormatSystem:
				deduplicate[mimeTypes[i].Type] = mimeTypes[i]
			case dataFormatIanaCSV:
				if mimeTypes[i].Src == dataFormatNginxConfig || mimeTypes[i].Src == dataFormatIanaCSV {
					deduplicate[mimeTypes[i].Type] = mimeTypes[i]
				}
			}
			continue
		}
		deduplicate[mimeTypes[i].Type] = mimeTypes[i]
	}
	// Создание имён констант.
	CreateConstantName(deduplicate)
	// Применение приоритетных настраиваемых типов MIME к расширениям.
	deduplicate = priorityReplace(deduplicate, prio)
	// Удаление повторов среди расширений имён файлов.
	deduplicateExtensionSlice(deduplicate)
	// Генерация файла.
	buf.Reset()
	// Разбор шаблона.
	die(func() (err error) {
		defer func() {
			if e := recover(); e != nil {
				err = fmt.Errorf("%s", e)
			}
		}()
		packageTemplate, err = template.New(resultFile).
			Funcs(map[string]any{
				"arr": func(in []string) (ret string) {
					for n := range in {
						if ret != "" {
							ret += ", "
						}
						ret = fmt.Sprintf("%s%q", ret, in[n])
					}
					return
				},
			}).
			Parse(resultTemplate)
		return
	}, "ошибка в синтаксисе шаблона: %s")
	// Формирование данных на основе шаблона.
	die(func() (err error) {
		defer func() {
			if e := recover(); e != nil {
				err = fmt.Errorf("%s", e)
			}
		}()
		return packageTemplate.Execute(buf, struct {
			Timestamp time.Time
			Folder    string
			Types     map[string]*MimeTypeItem
		}{
			Timestamp: time.Now().In(time.UTC),
			Folder:    sourceData,
			Types:     deduplicate,
		})
	}, "шаблонизатор завершился ошибкой: %s")
	// Форматирование кода и сохранение.
	if data, err = format.Source(buf.Bytes()); err != nil {
		log.Fatalf("форматирование созданного .go файла прервано ошибкой: %s", err)
		return
	}
	if err = os.WriteFile(resultFile, data, os.FileMode(0644)); err != nil {
		log.Fatalf("создание файла %q прервано ошибкой: %s", resultFile, err)
		return
	}

	return
}

func priorityReplace(data map[string]*MimeTypeItem, prio []*MimeTypeItem) map[string]*MimeTypeItem {
	var (
		key       string
		found, ok bool
		e, p, j   int
		ext       []string
	)

	// Поиск расширения имени файла среди всех MIME типов, удаление расширения имени файла.
	for key = range data {
		ext = make([]string, 0, len(data[key].Extension))
		for e = range data[key].Extension {
			found = false
			for p = range prio {
				for j = range prio[p].Extension {
					if data[key].Extension[e] == prio[p].Extension[j] {
						found = true
						break
					}
				}
			}
			if !found {
				ext = append(ext, data[key].Extension[e])
			}
		}
		data[key].Extension = make([]string, 0, len(ext))
		data[key].Extension = append(data[key].Extension, ext...)
	}
	// Поиск MIME типов
	for p = range prio {
		if _, ok = data[prio[p].Type]; ok {
			// Добавление расширения имени файла, если его нет в найденном MIME типе.
			for j = range prio[p].Extension {
				found = false
				for e = range data[prio[p].Type].Extension {
					if data[prio[p].Type].Extension[e] == prio[p].Extension[j] {
						found = true
						break
					}
				}
				if !found {
					data[prio[p].Type].Extension = append(data[prio[p].Type].Extension, prio[p].Extension[j])
				}
			}
			continue
		}
		// Добавление MIME типа с расширениями, если MIME тип ранее не был найден.
		data[prio[p].Type] = prio[p]
	}

	return data
}

func die(f func() error, ft string, ag ...any) {
	var err error

	if err = f(); err == nil {
		return
	}
	ag = append(ag, err)
	log.Fatalf(ft, ag...)
}

// CreateConstantName Создание имён констант.
func CreateConstantName(data map[string]*MimeTypeItem) {
	const prefix, delimiter = `mime`, ``
	var (
		tn  string
		tmp []string
		bts string
		i   int
	)

	for tn = range data {
		tmp = rexSplitter.Split(tn, -1)
		for i = range tmp {
			bts = tmp[i]
			if len(bts) > 0 {
				bts = strings.ToUpper(string(bts[0])) + string(bts[1:])
			}
			tmp[i] = bts
		}
		data[tn].Name = prefix + strings.Join(tmp, delimiter)
	}
}

func deduplicateExtensionSlice(data map[string]*MimeTypeItem) {
	for tn := range data {
		data[tn].Extension = deduplicateStringSlice(data[tn].Extension)
	}

	return
}

func deduplicateStringSlice(s []string) (ret []string) {
	var (
		tmp map[string]bool
		key string
		n   int
		ok  bool
	)

	tmp = make(map[string]bool)
	for n = range s {
		key = strings.TrimSpace(strings.ToLower(s[n]))
		if _, ok = tmp[key]; ok {
			continue
		}
		tmp[key] = ok
	}
	ret = make([]string, 0, len(tmp))
	for key = range tmp {
		ret = append(ret, key)
	}

	return
}

// ReadFileBody Чтение содержимого файла.
func ReadFileBody(filename string) (ret *bytes.Buffer, ext string, err error) {
	var (
		buf []byte
		str []string
	)

	if buf, err = ioutil.ReadFile(filename); err != nil {
		return
	}
	ret = bytes.NewBuffer(buf)
	if str = rexExtension.FindStringSubmatch(filename); len(str) >= 2 {
		ext = strings.ToLower(str[1])
	}

	return
}

// ParserDataFormatNginxConfig Разбор формата файла nginx configuration.
func ParserDataFormatNginxConfig(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	const (
		bBegin     = '{'
		bEnd       = '}'
		bReturn    = '\r'
		bNewLine   = '\n'
		bSemicolon = ';'
	)
	var (
		bbf  *bytes.Buffer
		rdr  *bufio.Reader
		buf  []byte
		line string
		tmp  []*MimeTypeItem
	)

	rdr = bufio.NewReader(data)
	if _, err = rdr.ReadBytes(bBegin); err != nil {
		return
	}
	if buf, err = rdr.ReadBytes(bEnd); err != nil {
		return
	}
	if len(buf) > 0 {
		buf = buf[:len(buf)-1]
	}
	buf = bytes.Replace(buf, []byte{bReturn}, []byte(""), -1)
	buf = bytes.Replace(buf, []byte{bNewLine}, []byte(""), -1)
	bbf = bytes.NewBuffer(buf)
	rdr = bufio.NewReader(bbf)
	for {
		line, err = rdr.ReadString(bSemicolon)
		line = strings.TrimSpace(strings.TrimRight(line, string(bSemicolon)))
		if len(line) != 0 {
			if tmp = ParserDataFormatNginxConfigItem(line); len(tmp) > 0 {
				ret = append(ret, tmp...)
			}
		}
		if err != nil {
			err = nil
			break
		}
	}

	return
}

// ParserDataFormatNginxConfigItem Обработка одной записи в формате nginx.
func ParserDataFormatNginxConfigItem(line string) (ret []*MimeTypeItem) {
	var (
		tmp []string
		ext []string
		i   int
	)

	tmp = strings.SplitAfterN(line, " ", 2)
	if len(tmp) < 2 {
		return
	}
	if tmp[0] = strings.TrimSpace(tmp[0]); len(tmp[0]) == 0 {
		return
	}
	ext = strings.Split(tmp[1], " ")
	for i = range ext {
		if ext[i] = strings.TrimSpace(ext[i]); len(ext[i]) == 0 {
			continue
		}
		if rexExtensionBad.MatchString(ext[i]) {
			continue
		}
		ret = append(ret, &MimeTypeItem{
			Type:      strings.ToLower(tmp[0]),
			Extension: []string{strings.ToLower(ext[i])},
			Src:       dataFormatNginxConfig,
		})
	}

	return
}

// ParseDataFormatSystem Разбор формата файла linux и apache.
func ParseDataFormatSystem(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	const bComment = '#'
	var (
		scn                 *bufio.Scanner
		tmp                 []string
		mimeType, extension string
	)

	scn = bufio.NewScanner(data)
	for scn.Scan() {
		tmp = strings.Fields(scn.Text())
		if len(tmp) <= 1 || tmp[0][0] == bComment {
			continue
		}
		mimeType = tmp[0]
		for _, extension = range tmp[1:] {
			if extension[0] == bComment {
				break
			}
			if rexExtensionBad.MatchString(extension) {
				continue
			}
			ret = append(ret, &MimeTypeItem{
				Type:      strings.ToLower(mimeType),
				Extension: []string{strings.ToLower(extension)},
				Src:       dataFormatSystem,
			})
		}
	}
	ret = filterMimeTypeItem(ret)

	return
}

// ParseDataFormatIanaCSV Разбор формата файла https://www.iana.org/assignments/media-types/media-types.xhtml.
func ParseDataFormatIanaCSV(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	var (
		rdr     *csv.Reader
		tmp     []*MimeTypeItem
		record  []string
		numLine uint64
	)

	rdr = csv.NewReader(data)
	for {
		numLine++
		record, err = rdr.Read()
		if numLine == 1 {
			continue
		}
		if len(record) >= 3 {
			if tmp = ParseDataFormatIanaCSVItem(record); len(tmp) > 0 {
				ret = append(ret, tmp...)
			}
		}
		if err != nil {
			err = nil
			break
		}
	}
	ret = filterMimeTypeItem(ret)

	return
}

// ParseDataFormatIanaCSVItem Разбор строки CSV файла.
func ParseDataFormatIanaCSVItem(record []string) (ret []*MimeTypeItem) {
	var (
		mimeType  string
		extension string
		tmp       []string
	)

	if mimeType = strings.TrimSpace(record[1]); len(mimeType) == 0 {
		return
	}
	if tmp = rexIanaExtension.FindStringSubmatch(record[0]); len(tmp) >= 2 {
		extension = strings.TrimSpace(tmp[1])
	}
	if rexExtensionBad.MatchString(extension) {
		return
	}
	ret = append(ret, &MimeTypeItem{
		Type:      strings.ToLower(mimeType),
		Extension: []string{strings.ToLower(extension)},
		Src:       dataFormatIanaCSV,
	})
	ret = filterMimeTypeItem(ret)

	return
}

func filterMimeTypeItem(in []*MimeTypeItem) (ret []*MimeTypeItem) {
	var (
		rsp   []*MimeTypeItem
		item  *MimeTypeItem
		n, j  int
		found bool
	)

	// Сложение по расширению файла.
	rsp = make([]*MimeTypeItem, 0, len(in))
	for n = range in {
		found = false
		for j = range rsp {
			if rsp[j].Type == in[n].Type {
				found, rsp[j].Extension = true, append(rsp[j].Extension, in[n].Extension...)
			}
		}
		if !found {
			rsp = append(rsp, in[n])
		}
	}
	// Удаление расширений содержащих одну и более точек.
	ret = make([]*MimeTypeItem, 0, len(rsp))
	for n = range rsp {
		item = &MimeTypeItem{
			Type:      rsp[n].Type,
			Src:       rsp[n].Src,
			Name:      rsp[n].Name,
			Extension: make([]string, 0, len(rsp[n].Extension)),
		}
		for j = range rsp[n].Extension {

			switch len(strings.Split(rsp[n].Extension[j], ".")) {
			case 0:
				continue
			case 1:
				item.Extension = append(item.Extension, rsp[n].Extension[j])
			default:
				continue
			}
		}
		if len(item.Extension) == 0 {
			continue
		}
		ret = append(ret, item)
	}

	return
}

// ParseDataFormatXCustom Разбор формата приоритетных настраиваемых типов MIME.
func ParseDataFormatXCustom(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	const bComment, sep, keySemicolon, prefix = '#', "|", ";", "mime"
	var (
		scn  *bufio.Scanner
		text string
		line []string
		ext  []string
		tmp  []string
		n, j int
	)

	scn = bufio.NewScanner(data)
	for scn.Scan() {
		text = strings.TrimSpace(scn.Text())
		if len(text) <= 1 || text[0] == bComment {
			continue
		}
		if line = strings.Split(text, sep); len(line) != 3 {
			continue
		}
		ext = strings.Split(line[1], keySemicolon)
		for n = range ext {
			ext[n] = strings.ToLower(strings.TrimSpace(ext[n]))
		}
		ret = append(ret, &MimeTypeItem{
			Type:      strings.ToLower(strings.TrimSpace(line[0])),
			Extension: append([]string{}, ext...),
			Src:       text,
		})
		ret = filterMimeTypeItem(ret)
	}
	ret = filterMimeTypeItem(ret)
	for n = range ret {
		tmp = rexSplitter.Split(ret[n].Type, -1)
		for j = range tmp {
			text = tmp[j]
			if len(text) > 0 {
				text = strings.ToUpper(string(text[0])) + string(text[1:])
			}
			tmp[j] = text
		}
		ret[n].Name = prefix + strings.Join(tmp, "")
	}

	return
}
