//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"go/format"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"
)

const (
	sourceFile     = "mime.txt"
	resultFile     = "mime_constants.go"
	resultTemplate = `// НЕ РЕДАКТИРОВАТЬ! Изменения будут перезаписаны при следующей кодогенерации.
// Code generated by go generate; DO NOT EDIT.

package dic

// Mimes Структура справочника MIME типов.
type Mimes struct {
{{- range .}}
	// {{.Name}} Тип MIME "{{.Source}}", {{.Description}}
	{{.Name}}	IMime
{{- end}}
}

func init() {
	singletonMimes = Mimes{
{{- range .}}
		{{.Name}}: &tMime{main: "{{.Mime.Main}}", subt: "{{.Mime.Subt}}", opts: map[string]string{ {{- range $index, $element := .Mime.Opts}}"{{$index}}": "{{$element}}"
{{- end -}}
}},
{{- end}}
	}
}
`
)

// TMime Структура объекта MIME типа.
type TMime struct {
	Main string            // Основной тип MIME.
	Subt string            // Подтип MIME.
	Opts map[string]string // Атрибуты MIME типа.
}

type source struct {
	Name        string
	Source      string
	Description string
	Mime        *TMime
}

func main() {
	var (
		err    error
		src    []*source
		result *bytes.Buffer
		tpl    *template.Template
		data   []byte
	)

	if src, err = readSource(sourceFile); err != nil {
		log.Fatalf("чтение файла %q прервано ошибкой: %s", sourceFile, err)
		return
	}
	sort.SliceStable(src, func(i, j int) bool { return strings.Compare(src[i].Name, src[j].Name) == -1 })
	result = &bytes.Buffer{}
	tpl = template.Must(template.New(resultFile).Parse(resultTemplate))
	if err = tpl.Execute(result, src); err != nil {
		log.Fatalf("шаблонизатор завершился с ошибкой: %s", err)
		return
	}
	if data, err = format.Source(result.Bytes()); err != nil {
		log.Fatalf("форматирование созданного .go файла прервано ошибкой: %s", err)
		return
	}
	if err = os.WriteFile(resultFile, data, os.FileMode(0644)); err != nil {
		log.Fatalf("создание файла %q прервано ошибкой: %s", resultFile, err)
		return
	}
}

func readSource(f string) (ret []*source, err error) {
	const sep = "|"
	var (
		data    []byte
		scanner *bufio.Scanner
		line    []string
	)

	if data, err = os.ReadFile(f); err != nil {
		return
	}
	scanner = bufio.NewScanner(bytes.NewBuffer(data))
	for scanner.Scan() {
		if line = strings.Split(scanner.Text(), sep); len(line) != 3 {
			continue
		}
		ret = append(ret, &source{
			Name:        strings.TrimSpace(line[0]),
			Source:      strings.TrimSpace(line[1]),
			Description: strings.TrimSpace(line[2]),
			Mime:        parseMime(strings.TrimSpace(line[1])),
		})
	}

	return
}

func parseMime(s string) *TMime {
	const keySlash, keyEqual, keySemicolon = "/", "=", ";"
	var (
		clean func(string) string
		mto   *TMime
		sss   []string
		tmp   []string
		n     int
	)

	clean = func(s string) string { return strings.ToLower(strings.TrimSpace(s)) }
	mto, sss = &TMime{Opts: make(map[string]string)}, strings.Split(s, keySemicolon)
	switch tmp = strings.Split(sss[0], keySlash); len(tmp) {
	case 1:
		mto.Main = clean(tmp[0])
	default:
		mto.Main = clean(tmp[0])
		mto.Subt = clean(tmp[1])
	}
	if len(sss) < 2 {
		return mto
	}
	for n = 1; n < len(sss); n++ {
		switch tmp = strings.Split(sss[n], keyEqual); len(tmp) {
		case 2:
			mto.Opts[clean(tmp[0])] = clean(tmp[1])
		}
	}

	return mto
}
